# 文档刷新时的章节层级划分算法

## 概述

当系统刷新文档时，MarkdownScanner 会解析 Markdown 文件，将其内容按照标题层级自动划分为树状结构的章节体系。算法采用**局部动态分层策略**，通过全局预扫描分析每个父章节下不同层级子章节的内容平均长度，为每个父章节独立确定最优的章节划分层级，确保每个父章节下的子章节内容长度接近目标值（例如 3000 字符）。

**核心特点**：
- **局部动态**：不是全局统一使用一个层级，而是每个父章节可以有不同的划分深度
- **自适应**：根据每个父章节的内容规模和子章节长度分布，自动选择最优层级
- **灵活**：同一个文档中，不同章节可以划分到不同的层级
- **目标导向**：确保每个父章节下的子章节内容长度接近目标值，既不过于细碎也不过于冗长

**示例场景**：
- 第二章的 H2 子章节平均 2800 字符 → 选择 H2 作为第二章的划分层级
- 第三章的 H2 子章节平均 8000 字符，H3 子章节平均 2500 字符 → 选择 H3 作为第三章的划分层级

## 核心概念

### 标题层级

Markdown 文档中的标题通过 `#` 符号的数量表示层级：
- `# 标题` → 一级标题（H1）
- `## 标题` → 二级标题（H2）
- `### 标题` → 三级标题（H3）
- 以此类推，最多支持六级标题（H6）

### 章节属性

每个解析出的章节包含以下关键信息：
- **SectionId**：章节的唯一标识符
- **HeadingPath**：从文档根到当前章节的完整标题路径
- **SectionLevel**：章节的层级深度（1-6）
- **ContentLength**：该章节包含内容的字符数
- **Paragraphs**：该章节包含的段落内容
- **SubSections**：该章节的子章节列表

### 目标分段长度

算法的目标是找到合适的层级划分，使得该层级下所有章节的内容长度接近一个理想值（例如 3000 字符）。这个理想值可以根据实际需求调整。

## 算法流程

### 阶段一：全局预扫描

#### 1.1 文档遍历与标题提取

算法首先进行一次完整的文档遍历，提取所有标题信息：
- 扫描每一行，识别标题行（以 `#` 开头）
- 记录每个标题的层级（`#` 的数量）
- 记录每个标题的行号位置
- 统计文档中出现的所有标题层级（例如：H1、H2、H3、H4）

#### 1.2 构建标题树

基于提取的标题信息，构建一个完整的标题树结构：
- 每个标题作为树的一个节点
- 根据标题层级建立父子关系
- 计算每个节点下包含的内容范围（从该标题到下一个同级或更高级标题之间的所有内容）

#### 1.3 计算各层级平均长度

对标题树进行后序遍历，计算每个层级下所有章节的内容长度：
- 对于每个层级（H1、H2、H3...），统计该层级下所有章节的内容长度
- 计算该层级的平均内容长度
- 记录该层级下章节长度的分布情况（最小值、最大值、标准差）

### 阶段二：确定最优层级

#### 2.1 分析层级长度分布

根据预扫描结果，分析各层级下每个父章节的子章节平均长度：
- 对于每个父章节，计算其下不同层级子章节的平均长度
- 例如：对于 H1 章节"第二章"，计算其下 H2 子章节的平均长度、H3 子章节的平均长度等
- 对于每个父章节，计算其下 H3 子章节的平均长度等

#### 2.2 局部动态分层策略

**核心思想**：不是全局统一使用一个层级，而是根据每个父章节下的子章节内容长度动态决定划分层级。每个父章节可以有不同的划分深度。

**分层策略**：

对于每个父章节，按照以下规则确定其最优划分层级：

**规则一：目标长度匹配**
- 计算该父章节下不同层级子章节的平均长度
- 选择平均长度最接近目标值（例如 3000 字符）的层级
- 例如：
  - 第二章的 H2 子章节平均 2800 字符 → 选择 H2 作为第二章的划分层级
  - 第三章的 H2 子章节平均 8000 字符，H3 子章节平均 2500 字符 → 选择 H3 作为第三章的划分层级

**规则二：避免过细划分**
- 如果某个层级的平均长度远小于目标值（例如小于 500 字符），则跳过该层级
- 例如：如果 H4 平均只有 200 字符，则不选择 H4，而是选择 H3

**规则三：避免过粗划分**
- 如果某个层级的平均长度远大于目标值（例如大于 10000 字符），则继续寻找更细的层级
- 例如：如果 H2 平均 12000 字符，H3 平均 3000 字符，则选择 H3

**规则四：层级连续性**
- 优先选择连续的层级，避免跳跃
- 例如：如果父章节有 H2、H3、H4 子章节，优先从 H2 或 H3 中选择，而不是直接选择 H4

**规则五：最小深度优先**
- 如果多个层级的平均长度都接近目标值，优先选择较浅的层级
- 例如：H2 平均 2800 字符，H3 平均 2600 字符，都接近 3000 字符，则选择 H2

#### 2.3 动态调整目标值

根据每个父章节的内容规模动态调整目标值：
- 小章节（总字数 < 5000）：目标值调整为 1500-2000 字符
- 中等章节（总字数 5000-20000）：目标值调整为 2500-3500 字符
- 大章节（总字数 > 20000）：目标值调整为 3000-4000 字符

#### 2.4 分层决策示例

假设有以下文档结构：

```
# 第一章 人工智能概述（总字数：8000）
  ## 1.1 什么是人工智能（字数：4000）
  ## 1.2 人工智能的发展历程（字数：4000）

# 第二章 智能体发展史（总字数：25000）
  ## 2.1 基于符号与逻辑的早期智能体（字数：8000）
    ### 2.1.1 物理符号系统假说（字数：2000）
    ### 2.1.2 专家系统（字数：3000）
    ### 2.1.3 SHRDLU（字数：3000）
  ## 2.2 基于学习的智能体（字数：7000）
    ### 2.2.1 机器学习基础（字数：2500）
    ### 2.2.2 深度学习（字数：4500）
  ## 2.3 现代智能体（字数：10000）
    ### 2.3.1 大语言模型（字数：5000）
      #### 2.3.1.1 Transformer架构（字数：2500）
      #### 2.3.1.2 预训练与微调（字数：2500）
    ### 2.3.2 多模态智能体（字数：5000）

# 第三章 智能体应用（总字数：6000）
  ## 3.1 智能客服（字数：2000）
  ## 3.2 智能推荐（字数：2000）
  ## 3.3 智能驾驶（字数：2000）
```

**分层决策过程**：

**第一章**：
- H2 子章节平均长度：4000 字符
- 目标值：3000 字符
- 决策：H2 平均长度 4000 字符，略大于目标值，但 H3 子章节不存在
- 结论：第一章划分到 H2 层

**第二章**：
- H2 子章节平均长度：8333 字符（8000+7000+10000）/3
- 目标值：3000 字符
- H2 平均长度远大于目标值，继续检查 H3
- H3 子章节平均长度：3125 字符（2000+3000+3000+2500+4500+5000+5000）/7
- 决策：H3 平均长度 3125 字符，接近目标值 3000 字符
- 结论：第二章划分到 H3 层

**第三章**：
- H2 子章节平均长度：2000 字符
- 目标值：3000 字符
- 决策：H2 平均长度 2000 字符，略小于目标值，但 H3 子章节不存在
- 结论：第三章划分到 H2 层

**最终分层结果**：
- 第一章：划分到 H2 层
- 第二章：划分到 H3 层
- 第三章：划分到 H2 层

### 阶段三：正式划分

#### 3.1 根据局部最优层级构建章节

根据阶段二确定的每个父章节的最优层级，正式构建章节结构：
- 对于每个父章节，只保留其最优层级及其更高级别的子标题
- 忽略低于最优层级的标题（将它们的内容合并到父章节中）
- 建立清晰的父子关系
- 不同父章节可以有不同的划分深度

#### 3.2 段落归属

每个段落归属于其最近的前一个标题对应的章节：
- 如果段落之前有标题，则归属于该标题对应的章节
- 如果段落之前没有标题，则归属于文档根章节
- 不做段落合并，保留原文的段落结构

#### 3.3 段落划分

段落划分采用**基于 Markdown 语法的简单划分方式**，不使用大语言模型进行智能划分：

**划分规则**：
- 两个空行之间的内容被视为一个段落
- 遇到标题、列表、代码块、引用等元素时段落结束
- 保留原文的段落结构，不做合并或改写

**段落类型**：
- **Text**：普通文本段落
- **List**：列表段落（无序列表或有序列表）
- **Code**：代码块段落
- **Quote**：引用块段落
- **Table**：表格段落

**段落属性**：
- **ParagraphId**：段落唯一标识符
- **Content**：段落内容（原文）
- **StartLine**：段落起始行号
- **EndLine**：段落结束行号
- **Type**：段落类型

#### 3.4 内容长度统计

为每个章节统计内容长度：
- 计算每个章节包含的所有段落的字符总数
- 记录章节的 ContentLength 属性

**内容过滤规则**：
在统计章节字符数时，会自动过滤以下内容，确保统计的是实际文本内容：
- **代码块**：跳过 ``` 包裹的代码块内容
- **HTML标签**：移除所有HTML标签（如 `<img>`, `<a>`, `<div>` 等）
- **Markdown图片链接**：移除 `![alt](url)` 格式的图片链接
- **Markdown链接URL**：对于 `[text](url)` 格式的链接，只保留链接文本 `text`，移除URL部分

这样计算出的字符数更准确地反映实际文本内容，避免代码块和格式信息干扰章节划分决策。

## 示例

假设有以下 Markdown 文档：

```markdown
# 第一章 人工智能概述

人工智能是计算机科学的一个重要分支，它研究如何利用计算机模拟、延伸和扩展人的智能。人工智能的研究领域非常广泛，包括机器学习、自然语言处理、计算机视觉、专家系统等多个方向。

## 1.1 什么是人工智能

人工智能是指由人制造出来的机器所表现出来的智能。这种智能通常包括学习、推理、问题解决、理解语言、感知环境等能力。人工智能的目标是创建能够执行通常需要人类智能才能完成的任务的系统。

### 1.1.1 人工智能的定义

人工智能的定义有多种，但核心是让机器具备类似人类的智能行为。从技术角度看，人工智能是计算机科学的一个分支，致力于研究如何让计算机模拟人类的思维过程。

### 1.1.2 人工智能的特点

人工智能具有以下几个特点：
1. 感知能力：能够感知外部环境
2. 学习能力：能够从数据中学习
3. 推理能力：能够进行逻辑推理
4. 决策能力：能够做出合理决策

## 1.2 人工智能的发展历程

人工智能的发展可以分为几个阶段：符号主义、连接主义和行为主义。每个阶段都有其独特的理论和方法，共同推动了人工智能的发展。

### 1.2.1 符号主义阶段

符号主义是人工智能的早期阶段，主要基于逻辑推理和知识表示。这一阶段的代表性成果包括专家系统、知识工程等。

### 1.2.2 连接主义阶段

连接主义阶段以神经网络为基础，强调从数据中学习。这一阶段的代表性成果包括深度学习、卷积神经网络等。

### 1.2.3 行为主义阶段

行为主义阶段强调智能体与环境的交互，通过试错学习来改进行为。这一阶段的代表性成果包括强化学习、进化算法等。

# 第二章 智能体发展史

为了深刻理解现代智能体为何呈现出如今的形态，以及其核心设计思想的由来，本章将回溯历史：从人工智能领域的古典时代出发，探寻最早的"智能"如何在逻辑与符号的规则体系中被定义；继而见证从单一、集中的智能模型到分布式、协作式智能思想的重大转折；最终理解"学习"范式如何彻底改变了智能体获取能力的方式，并催生出我们今天所见的现代智能体。

## 2.1 基于符号与逻辑的早期智能体

人工智能领域的早期探索，深受数理逻辑和计算机科学基本原理的影响。在那个时代，研究者们普遍持有一种信念：人类的智能，尤其是逻辑推理能力，可以被形式化的符号体系所捕捉和复现。这一核心思想催生了人工智能的第一个重要范式——符号主义，也被称为"逻辑AI"或"传统AI"。

### 2.1.1 物理符号系统假说

符号主义时代的理论根据，是1976年由艾伦·纽厄尔和赫伯特·西蒙共同提出的物理符号系统假说。这两位图灵奖得主通过这一假说，为在计算机上实现通用人工智能提供了理论指导和判定标准。

### 2.1.2 专家系统

在物理符号系统假说的直接影响下，专家系统成为符号主义时代最重要、最成功的应用成果。专家系统的核心目标，是模拟人类专家在特定领域内解决问题的能力。

### 2.1.3 SHRDLU

如果说专家系统展示了符号AI在专业领域的"深度"，那么由特里·威诺格拉德于1968-1970年开发的SHRDLU项目，则在"广度"上实现了革命性的突破。

## 2.2 基于学习的智能体

随着计算能力的提升和数据规模的扩大，基于学习的智能体逐渐成为主流。这一阶段的智能体不再依赖预先编码的知识库，而是通过从数据中学习来获取能力。

### 2.2.1 机器学习基础

机器学习是人工智能的一个子领域，它研究如何让计算机从数据中学习规律，并利用这些规律对未知数据进行预测或决策。

### 2.2.2 深度学习

深度学习是机器学习的一个分支，它使用多层神经网络来学习数据的层次化表示。深度学习在图像识别、语音识别、自然语言处理等领域取得了巨大成功。

## 2.3 现代智能体

现代智能体结合了符号主义和连接主义的优势，同时具备强大的学习能力和推理能力。大语言模型是现代智能体的典型代表。

### 2.3.1 大语言模型

大语言模型是近年来人工智能领域的重大突破，它通过在海量文本数据上进行预训练，学习到了丰富的语言知识和世界知识。

#### 2.3.1.1 Transformer架构

Transformer架构是大语言模型的核心技术，它通过自注意力机制实现了对长距离依赖的有效建模。

#### 2.3.1.2 预训练与微调

预训练与微调是大语言模型的训练范式，预训练阶段在海量数据上学习通用知识，微调阶段在特定任务上调整模型参数。

### 2.3.2 多模态智能体

多模态智能体能够处理多种类型的数据，包括文本、图像、音频、视频等。多模态智能体在智能客服、智能推荐、智能驾驶等领域有广泛应用。

# 第三章 智能体应用

智能体在各个领域都有广泛的应用，包括智能客服、智能推荐、智能驾驶等。

## 3.1 智能客服

智能客服是智能体在客服领域的应用，它能够自动回答用户的问题，提供7x24小时的服务。

## 3.2 智能推荐

智能推荐是智能体在推荐领域的应用，它能够根据用户的历史行为和偏好，推荐个性化的内容。

## 3.3 智能驾驶

智能驾驶是智能体在汽车领域的应用，它能够实现自动驾驶，提高行车安全性和效率。
```

### 预扫描结果

假设目标值为 3000 字符，预扫描结果如下：

**第一章**：
- H2 子章节：2个，平均长度 4000 字符
- H3 子章节：5个，平均长度 1600 字符

**第二章**：
- H2 子章节：3个，平均长度 8333 字符
- H3 子章节：7个，平均长度 3571 字符
- H4 子章节：2个，平均长度 2500 字符

**第三章**：
- H2 子章节：3个，平均长度 2000 字符
- H3 子章节：0个

### 层级选择

**第一章**：
- H2 平均长度 4000 字符，略大于目标值 3000
- H3 平均长度 1600 字符，小于目标值 3000
- 决策：H2 平均长度更接近目标值，且 H3 层级不存在（H3 是 H2 的子章节）
- 结论：第一章划分到 H2 层

**第二章**：
- H2 平均长度 8333 字符，远大于目标值 3000，过粗
- H3 平均长度 3571 字符，接近目标值 3000
- H4 平均长度 2500 字符，略小于目标值 3000
- 决策：H3 平均长度最接近目标值
- 结论：第二章划分到 H3 层

**第三章**：
- H2 平均长度 2000 字符，略小于目标值 3000
- H3 子章节不存在
- 决策：H2 平均长度接近目标值，且没有更细的层级
- 结论：第三章划分到 H2 层

### 最终章节结构

```
文档根
└── Section_0 (H1: 第一章 人工智能概述)
    ├── ContentLength: 8000
    ├── Paragraphs: [段落1]
    └── SubSections:
        ├── Section_1 (H2: 1.1 什么是人工智能)
        │   ├── ContentLength: 4000
        │   ├── Paragraphs: [段落2, 段落3, 段落4, 段落5]
        │   └── SubSections: []
        └── Section_2 (H2: 1.2 人工智能的发展历程)
            ├── ContentLength: 4000
            ├── Paragraphs: [段落6, 段落7, 段落8, 段落9]
            └── SubSections: []

└── Section_3 (H1: 第二章 智能体发展史)
    ├── ContentLength: 25000
    ├── Paragraphs: [段落10]
    └── SubSections:
        ├── Section_4 (H2: 2.1 基于符号与逻辑的早期智能体)
        │   ├── ContentLength: 8000
        │   ├── Paragraphs: [段落11]
        │   └── SubSections:
        │       ├── Section_5 (H3: 2.1.1 物理符号系统假说)
        │       │   ├── ContentLength: 2000
        │       │   ├── Paragraphs: [段落12]
        │       │   └── SubSections: []
        │       ├── Section_6 (H3: 2.1.2 专家系统)
        │       │   ├── ContentLength: 3000
        │       │   ├── Paragraphs: [段落13]
        │       │   └── SubSections: []
        │       └── Section_7 (H3: 2.1.3 SHRDLU)
        │           ├── ContentLength: 3000
        │           ├── Paragraphs: [段落14]
        │           └── SubSections: []
        ├── Section_8 (H2: 2.2 基于学习的智能体)
        │   ├── ContentLength: 7000
        │   ├── Paragraphs: [段落15]
        │   └── SubSections:
        │       ├── Section_9 (H3: 2.2.1 机器学习基础)
        │       │   ├── ContentLength: 2500
        │       │   ├── Paragraphs: [段落16]
        │       │   └── SubSections: []
        │       └── Section_10 (H3: 2.2.2 深度学习)
        │           ├── ContentLength: 4500
        │           ├── Paragraphs: [段落17]
        │           └── SubSections: []
        └── Section_11 (H2: 2.3 现代智能体)
            ├── ContentLength: 10000
            ├── Paragraphs: [段落18]
            └── SubSections:
                ├── Section_12 (H3: 2.3.1 大语言模型)
                │   ├── ContentLength: 5000
                │   ├── Paragraphs: [段落19]
                │   └── SubSections: []
                └── Section_13 (H3: 2.3.2 多模态智能体)
                    ├── ContentLength: 5000
                    ├── Paragraphs: [段落20]
                    └── SubSections: []

└── Section_14 (H1: 第三章 智能体应用)
    ├── ContentLength: 6000
    ├── Paragraphs: [段落21]
    └── SubSections:
        ├── Section_15 (H2: 3.1 智能客服)
        │   ├── ContentLength: 2000
        │   ├── Paragraphs: [段落22]
        │   └── SubSections: []
        ├── Section_16 (H2: 3.2 智能推荐)
        │   ├── ContentLength: 2000
        │   ├── Paragraphs: [段落23]
        │   └── SubSections: []
        └── Section_17 (H2: 3.3 智能驾驶)
            ├── ContentLength: 2000
            ├── Paragraphs: [段落24]
            └── SubSections: []
```

**注意**：
- 第一章划分到 H2 层，H3 标题被忽略，内容合并到 H2 章节中
- 第二章划分到 H3 层，H4 标题被忽略，内容合并到 H3 章节中
- 第三章划分到 H2 层
- 不同章节有不同的划分深度，体现了局部动态分层策略

## 特殊情况处理

### 跨层级标题

当标题层级跨度较大时（例如从 H1 直接跳到 H4），算法会自动建立正确的父子关系，跳过中间的层级。

### 重复标题

即使标题文本相同，算法也能正确区分不同的章节，因为每个章节都有唯一的 SectionId。

### 无标题文档

如果文档中没有标题，所有段落将归属于一个默认的根章节。

### 内容长度差异过大

如果同一层级下不同章节的内容长度差异过大（标准差超过平均值的 50%），算法会考虑选择更细的层级，以平衡各章节的内容长度。

### 空章节

如果某个标题下没有内容（ContentLength = 0），算法会保留该章节，但标记为空章节，便于后续处理。

## 性能考虑

- 时间复杂度：O(n)，其中 n 是文档的行数
- 空间复杂度：O(m)，其中 m 是章节数量
- 算法采用两次遍历（预扫描 + 正式划分），效率较高，适合处理大型文档

## 参数配置

**重要说明**：以下所有参数必须在代码中实现为可配置项，允许通过项目的配置文件（如 `appsettings.json`）进行设置。这些参数的默认值如下，但应根据实际项目需求进行调整。

### 目标分段长度

**配置项名称**：`Sectioning:TargetLength`

**默认值**：3000 字符

**说明**：这是算法的核心目标值，用于确定每个父章节下的子章节平均长度应该接近的值。算法会为每个父章节选择一个层级，使得该层级下子章节的平均长度最接近此目标值。

**配置示例**：
```json
{
  "Sectioning": {
    "TargetLength": 3000
  }
}
```

**调整建议**：
- 小文档（总字数 < 10000）：建议设置为 1500-2000 字符
- 中等文档（总字数 10000-50000）：建议设置为 2500-3500 字符
- 大文档（总字数 > 50000）：建议设置为 3000-4000 字符

### 最小分段长度

**配置项名称**：`Sectioning:MinLength`

**默认值**：500 字符

**说明**：如果某个层级的平均长度低于此值，则该层级会被视为过细，算法会跳过该层级，选择更粗的层级。

**配置示例**：
```json
{
  "Sectioning": {
    "MinLength": 500
  }
}
```

**调整建议**：
- 如果希望章节更细一些，可以降低此值（例如 300 字符）
- 如果希望避免过于细碎的章节，可以提高此值（例如 800 字符）

### 最大分段长度

**配置项名称**：`Sectioning:MaxLength`

**默认值**：10000 字符

**说明**：如果某个层级的平均长度高于此值，则该层级会被视为过粗，算法会继续寻找更细的层级。

**配置示例**：
```json
{
  "Sectioning": {
    "MaxLength": 10000
  }
}
```

**调整建议**：
- 如果希望章节更粗一些，可以提高此值（例如 15000 字符）
- 如果希望避免过于冗长的章节，可以降低此值（例如 8000 字符）

### 章节规模分类阈值

**配置项名称**：`Sectioning:SizeThresholds`

**默认值**：
```json
{
  "Small": 5000,
  "Medium": 20000
}
```

**说明**：用于根据章节的总字数动态调整目标分段长度：
- 小章节（总字数 < Small）：目标值调整为 1500-2000 字符
- 中等章节（总字数 Small-Medium）：目标值调整为 2500-3500 字符
- 大章节（总字数 > Medium）：目标值调整为 3000-4000 字符

**配置示例**：
```json
{
  "Sectioning": {
    "SizeThresholds": {
      "Small": 5000,
      "Medium": 20000
    }
  }
}
```

**调整建议**：
- 如果文档整体较长，可以提高这些阈值
- 如果文档整体较短，可以降低这些阈值

### 层级选择策略权重

**配置项名称**：`Sectioning:StrategyWeights`

**默认值**：
```json
{
  "TargetLengthMatch": 1.0,
  "AvoidTooFine": 0.8,
  "AvoidTooCoarse": 0.8,
  "LevelContinuity": 0.6,
  "MinDepthFirst": 0.5
}
```

**说明**：用于调整不同规则在层级选择中的权重。权重越高，该规则的影响越大。

**配置示例**：
```json
{
  "Sectioning": {
    "StrategyWeights": {
      "TargetLengthMatch": 1.0,
      "AvoidTooFine": 0.8,
      "AvoidTooCoarse": 0.8,
      "LevelContinuity": 0.6,
      "MinDepthFirst": 0.5
    }
  }
}
```

**调整建议**：
- 如果更看重长度匹配，可以提高 `TargetLengthMatch` 的权重
- 如果更看重层级连续性，可以提高 `LevelContinuity` 的权重
- 如果更倾向于选择较浅的层级，可以提高 `MinDepthFirst` 的权重

### 完整配置示例

```json
{
  "Sectioning": {
    "TargetLength": 3000,
    "MinLength": 500,
    "MaxLength": 10000,
    "SizeThresholds": {
      "Small": 5000,
      "Medium": 20000
    },
    "StrategyWeights": {
      "TargetLengthMatch": 1.0,
      "AvoidTooFine": 0.8,
      "AvoidTooCoarse": 0.8,
      "LevelContinuity": 0.6,
      "MinDepthFirst": 0.5
    }
  }
}
```

### 配置实现要求

在代码中实现这些配置项时，需要满足以下要求：

1. **配置类定义**：创建一个配置类（如 `SectioningOptions`）来承载这些配置项
2. **配置绑定**：使用 .NET 的配置绑定机制，将配置文件中的值绑定到配置类
3. **依赖注入**：将配置类通过依赖注入注入到 `MarkdownScanner` 服务中
4. **默认值处理**：如果配置文件中没有提供某个配置项，使用默认值
5. **配置验证**：在启动时验证配置项的合法性（例如：MinLength < TargetLength < MaxLength）

**示例代码**：

```csharp
public class SectioningOptions
{
    public const string SectionName = "Sectioning";
    
    public int TargetLength { get; set; } = 3000;
    public int MinLength { get; set; } = 500;
    public int MaxLength { get; set; } = 10000;
    
    public SizeThresholdsOptions SizeThresholds { get; set; } = new();
    public StrategyWeightsOptions StrategyWeights { get; set; } = new();
}

public class SizeThresholdsOptions
{
    public int Small { get; set; } = 5000;
    public int Medium { get; set; } = 20000;
}

public class StrategyWeightsOptions
{
    public double TargetLengthMatch { get; set; } = 1.0;
    public double AvoidTooFine { get; set; } = 0.8;
    public double AvoidTooCoarse { get; set; } = 0.8;
    public double LevelContinuity { get; set; } = 0.6;
    public double MinDepthFirst { get; set; } = 0.5;
}
```

**在 Program.cs 中注册配置**：

```csharp
builder.Services.Configure<SectioningOptions>(
    builder.Configuration.GetSection(SectioningOptions.SectionName));
```

## 输出格式

解析结果以 JSON 格式输出，包含完整的层级结构、内容长度统计等信息，便于后续的知识体系构建和学习内容生成。

### 示例输出

```json
{
  "DocId": "h72Oa2bt6XWFSlBc",
  "Title": "第一章 人工智能概述",
  "OptimalLevel": 2,
  "TargetLength": 3000,
  "Sections": [
    {
      "SectionId": "section_0",
      "HeadingPath": ["第一章 人工智能概述"],
      "SectionLevel": 1,
      "ContentLength": 5000,
      "Paragraphs": [...],
      "SubSections": [
        {
          "SectionId": "section_1",
          "HeadingPath": ["第一章 人工智能概述", "1.1 什么是人工智能"],
          "SectionLevel": 2,
          "ContentLength": 2400,
          "Paragraphs": [...],
          "SubSections": []
        }
      ]
    }
  ]
}
```